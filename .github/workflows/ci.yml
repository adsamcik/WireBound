name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  DOTNET_VERSION: '10.0.x'
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_NOLOGO: true
  PROJECT_PATH: src/WireBound/WireBound.csproj

jobs:
  build:
    runs-on: windows-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Install MAUI workload
        run: dotnet workload install maui-windows

      - name: Restore dependencies
        run: dotnet restore WireBound.slnx

      - name: Build
        run: dotnet build WireBound.slnx --configuration Release --no-restore

      - name: Run tests
        run: dotnet test WireBound.slnx --configuration Release --no-build --verbosity normal
        continue-on-error: true

  code-quality:
    runs-on: windows-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Install MAUI workload
        run: dotnet workload install maui-windows

      - name: Restore dependencies
        run: dotnet restore WireBound.slnx

      - name: Check formatting
        run: dotnet format WireBound.slnx --verify-no-changes --verbosity diagnostic
        continue-on-error: true

  publish-validation:
    runs-on: windows-2022
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: Portable
            aot: false
            output: portable
          - name: AOT
            aot: true
            output: aot
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Install MAUI workload
        run: dotnet workload install maui-windows

      - name: Restore dependencies
        run: dotnet restore ${{ env.PROJECT_PATH }}

      - name: Publish ${{ matrix.name }} build
        shell: pwsh
        run: |
          $publishArgs = @(
            "publish", "${{ env.PROJECT_PATH }}",
            "--configuration", "Release",
            "--runtime", "win-x64",
            "--output", "./publish/${{ matrix.output }}",
            "-p:WindowsPackageType=None"
          )
          
          if ("${{ matrix.aot }}" -eq "true") {
            $publishArgs += "-p:EnableAOT=true"
          } else {
            $publishArgs += "-p:PublishReadyToRun=true"
          }
          
          & dotnet @publishArgs
        continue-on-error: ${{ matrix.aot }}

      - name: Validate ${{ matrix.name }} build artifacts
        shell: pwsh
        run: |
          $outputDir = "./publish/${{ matrix.output }}"
          $exePath = Join-Path $outputDir "WireBound.exe"
          
          if (-not (Test-Path $exePath)) {
            Write-Host "‚ùå Executable not found: $exePath"
            if ("${{ matrix.aot }}" -eq "true") {
              Write-Host "‚ö†Ô∏è AOT build may have failed due to trim/AOT warnings"
              exit 0  # Don't fail CI for AOT issues
            }
            exit 1
          }
          
          $exe = Get-Item $exePath
          $sizeMB = [math]::Round($exe.Length / 1MB, 2)
          Write-Host "‚úÖ Executable found: $sizeMB MB"
          
          # Validate PE headers
          $bytes = [System.IO.File]::ReadAllBytes($exePath)
          if ($bytes[0] -eq 0x4D -and $bytes[1] -eq 0x5A) {
            Write-Host "‚úÖ Valid PE executable header"
          } else {
            Write-Host "‚ùå Invalid PE header"
            exit 1
          }
          
          # Check for required dependencies
          $requiredFiles = @("WireBound.dll", "Microsoft.Maui.dll")
          if ("${{ matrix.aot }}" -ne "true") {
            foreach ($file in $requiredFiles) {
              $filePath = Join-Path $outputDir $file
              if (Test-Path $filePath) {
                Write-Host "‚úÖ Found: $file"
              } else {
                Write-Host "‚ö†Ô∏è Missing: $file (may be bundled)"
              }
            }
          }
          
          # Report file count and total size
          $files = Get-ChildItem $outputDir -File -Recurse
          $totalSize = ($files | Measure-Object -Property Length -Sum).Sum / 1MB
          Write-Host ""
          Write-Host "üìä Build Summary (${{ matrix.name }}):"
          Write-Host "   Files: $($files.Count)"
          Write-Host "   Total Size: $([math]::Round($totalSize, 2)) MB"

      - name: Install Windows App SDK Runtime
        shell: pwsh
        run: |
          Write-Host "üì¶ Installing Windows App SDK Runtime..."
          
          # Download the latest Windows App SDK runtime installer
          $installerUrl = "https://aka.ms/windowsappsdk/1.6/latest/windowsappruntimeinstall-x64.exe"
          $installerPath = "$env:TEMP\windowsappruntimeinstall-x64.exe"
          
          try {
            Invoke-WebRequest -Uri $installerUrl -OutFile $installerPath -UseBasicParsing
            Write-Host "‚úÖ Downloaded Windows App SDK installer"
            
            # Install silently with --quiet flag
            $process = Start-Process -FilePath $installerPath -ArgumentList "--quiet" -Wait -PassThru
            
            if ($process.ExitCode -eq 0) {
              Write-Host "‚úÖ Windows App SDK Runtime installed successfully"
            } else {
              Write-Host "‚ö†Ô∏è Windows App SDK Runtime installation returned: $($process.ExitCode)"
              Write-Host "   This may be expected if the runtime is already installed or requires elevation"
            }
          } catch {
            Write-Host "‚ö†Ô∏è Could not install Windows App SDK Runtime: $_"
            Write-Host "   Smoke test may fail with runtime dependency error"
          }
        continue-on-error: true

      - name: Smoke test - Validate app startup
        shell: pwsh
        run: |
          $exePath = "./publish/${{ matrix.output }}/WireBound.exe"
          
          if (-not (Test-Path $exePath)) {
            Write-Host "‚ö†Ô∏è Skipping smoke test - executable not found"
            exit 0
          }
          
          # MAUI apps require Windows App SDK runtime
          # We can validate the executable starts by checking it doesn't crash immediately
          try {
            $process = Start-Process -FilePath $exePath -PassThru -WindowStyle Hidden
            
            # Give the app time to initialize
            Start-Sleep -Seconds 3
            
            if ($process.HasExited) {
              $exitCode = $process.ExitCode
              if ($exitCode -eq 0) {
                Write-Host "‚úÖ App started and exited cleanly"
              } elseif ($exitCode -eq -1073741189) {
                # 0xC000027B - Windows App SDK dependency issue (expected in CI)
                Write-Host "‚ö†Ô∏è App requires Windows App SDK runtime (expected in CI environment)"
              } else {
                Write-Host "‚ö†Ô∏è App exited with code: $exitCode"
              }
            } else {
              Write-Host "‚úÖ App is running (PID: $($process.Id))"
              Stop-Process -Id $process.Id -Force -ErrorAction SilentlyContinue
              Write-Host "‚úÖ App stopped cleanly"
            }
          } catch {
            Write-Host "‚ö†Ô∏è Could not start app: $_"
          }
        continue-on-error: true

      - name: Upload ${{ matrix.name }} artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: WireBound-${{ matrix.output }}-ci
          path: ./publish/${{ matrix.output }}/
          retention-days: 7
          if-no-files-found: ignore

  aot-analysis:
    runs-on: windows-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Install MAUI workload
        run: dotnet workload install maui-windows

      - name: Restore dependencies
        run: dotnet restore ${{ env.PROJECT_PATH }}

      - name: Analyze trim warnings
        shell: pwsh
        run: |
          Write-Host "üìã Analyzing trim/AOT compatibility..."
          
          # Build with trim analysis enabled to report warnings
          $output = dotnet build ${{ env.PROJECT_PATH }} `
            --configuration Release `
            -p:PublishTrimmed=true `
            -p:TrimMode=full `
            -p:EnableTrimAnalyzer=true `
            -p:SuppressTrimAnalysisWarnings=false `
            2>&1
          
          $trimWarnings = $output | Select-String -Pattern "IL2\d{3}|IL3\d{3}" | Select-Object -Unique
          
          if ($trimWarnings.Count -gt 0) {
            Write-Host ""
            Write-Host "‚ö†Ô∏è Found $($trimWarnings.Count) unique trim/AOT warnings:"
            Write-Host ""
            $trimWarnings | ForEach-Object { Write-Host $_.Line }
          } else {
            Write-Host "‚úÖ No trim warnings found in application code"
          }
        continue-on-error: true

      - name: Check AOT compatibility annotations
        shell: pwsh
        run: |
          Write-Host "üîç Checking for AOT-friendly patterns..."
          
          # Check for RequiresDynamicCode/RequiresUnreferencedCode usage
          $sourceFiles = Get-ChildItem -Path src -Recurse -Include *.cs
          
          $patterns = @{
            "Source Generators" = "partial class|partial record"
            "JSON Source Gen" = "JsonSerializable|JsonSourceGenerationOptions"
            "Unsafe Blocks" = "unsafe\s*(struct|class|{)"
            "Dynamic Code" = "RequiresDynamicCode|DynamicallyAccessedMembers"
          }
          
          foreach ($pattern in $patterns.GetEnumerator()) {
            $matches = $sourceFiles | Select-String -Pattern $pattern.Value -List
            if ($matches.Count -gt 0) {
              Write-Host "‚úÖ $($pattern.Key): Found in $($matches.Count) file(s)"
            }
          }
        continue-on-error: true
